| Когда нужен `yield`   | Зачем                                         |
| --------------------- | --------------------------------------------- |
| Большие данные        | Читаем/генерируем по частям, не грузим память |
| Потоковая обработка   | Выдаём результат “на лету”                    |
| Контекстный менеджер  | Разделяем “вход” и “выход” (работа и очистка) |
| Отложенные вычисления | Не тратим ресурсы на ненужные результаты      |

3 главных причины использовать self.id = cur.lastrowid
Причина,Объяснение
1. Дальнейшая работа с объектом,"Чтобы потом обновлять, удалять или искать именно этот объект."
2. Связь с другими таблицами,"ID нужен как внешний ключ (user_id) в других таблицах (заказы, сообщения и т.д.)."
3. Удобство в коде,"Можно писать: user.id, а не делать новый запрос в базу."


Шаг - Что происходит
1.  - Python отправляет SQL-шаблон с ? в SQLite
2.  - "SQLite видит ? → ""тут будет значение"""
3.  - Python передаёт params — список значений
4.  - SQLite подставляет по порядку

1. База       | Плейсхолдер
2. SQLite     | ?
3. PostgreSQL | :name или %s
4. MySQL      | %s или ?

Ситуация - Что использовать
1. "Простая структура (API, config)" - dataclass
2. "Модель с методами (save, update, delete)" - Обычный класс
3. Нужно наследование - Обычный класс
4. Валидация в __init__ - Обычный класс
5. Хочешь __repr__ без кода - dataclass

Золотое правило
Пиши dataclass, если это «просто данные»
Пиши обычный класс, если есть поведение

Таблица: данные vs поведение

Признак                  - Только данные (dataclass)       - Есть поведение (обычный класс)
Поля                     - Есть                            - Есть
Методы                   - Нет / 1–2 простых               - "Есть, с логикой"
Изменение состояния      - Только через __init__           - Через методы
Пример                   - "Point, Config, - APIResponse"  - BankAccount -  User, Client"
"Нужен __repr__, __eq__" - Да                              - "Можно, но вручную"

Как выбрать — чек-лист
Спроси себя:

* Нужны ли методы, которые что-то делают?
→ Да → обычный класс
* Это просто структура для хранения?
→ Да → dataclass
* Буду ли я вызывать .save(), .update(), .send()?
→ Да → обычный класс
* Нужен только print(obj) и сравнение?
→ Да → dataclass